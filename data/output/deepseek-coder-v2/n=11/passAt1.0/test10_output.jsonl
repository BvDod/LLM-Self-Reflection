{"task_id": "HumanEval/0", "completion": "    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) <= threshold:\n            return True\n    return False"}
{"task_id": "HumanEval/1", "completion": "    paren_string = paren_string.replace(\" \", \"\")  # Remove all spaces\n    stack = []\n    result = []\n    current_group = \"\"\n    \n    for char in paren_string:\n        if char == '(':\n            if stack and stack[-1] != ')':\n                current_group += char\n            else:\n                if current_group:\n                    result.append(current_group)\n                current_group = char\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                top = stack.pop()\n                if top == '(':\n                    current_group += char\n                    if not stack:\n                        result.append(current_group)\n                        current_group = \"\"\n    return result"}
{"task_id": "HumanEval/2", "completion": "    return number - int(number)"}
{"task_id": "HumanEval/3", "completion": "    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"task_id": "HumanEval/4", "completion": "    if not numbers:\n        return 0\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad"}
{"task_id": "HumanEval/5", "completion": "    result = []\n    for i in range(len(numbers)):\n        if i > 0:\n            result.append(delimeter)\n        result.append(numbers[i])\n    return result"}
{"task_id": "HumanEval/6", "completion": "    def max_depth(s):\n        depth = 0\n        max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                if depth > max_depth:\n                    max_depth = depth\n            elif char == ')':\n                depth -= 1\n        return max_depth\n    \n    groups = paren_string.split()\n    results = []\n    for group in groups:\n        results.append(max_depth(group))\n    return results"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/8", "completion": "    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    if not numbers:\n        return (0, 1)\n    \n    total_sum = 0\n    product = 1\n    \n    for number in numbers:\n        total_sum += number\n        product *= number\n    \n    return (total_sum, product)"}
{"task_id": "HumanEval/9", "completion": "    if not numbers:\n        return []\n    \n    max_so_far = float('-inf')\n    result = []\n    \n    for num in numbers:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n    \n    return result"}
{"task_id": "HumanEval/10", "completion": "    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    if not string:\n        return ''\n    \n    def find_longest_palindrome_postfix(s):\n        for i in range(len(s)):\n            substring = s[i:]\n            if substring == substring[::-1]:\n                return substring\n        return ''\n    \n    longest_palindrome_postfix = find_longest_palindrome_postfix(string)\n    prefix = string[:len(string) - len(longest_palindrome_postfix)] if longest_palindrome_postfix else ''\n    reversed_prefix = prefix[::-1]\n    \n    return string + reversed_prefix"}
