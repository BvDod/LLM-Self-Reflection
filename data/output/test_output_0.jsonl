{"task_id": "HumanEval/0", "completion": "    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    return False"}
{"task_id": "HumanEval/1", "completion": "    def is_balanced(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    groups = []\n    group = ''\n    for c in paren_string:\n        if c == ' ':\n            continue\n        group += c\n        if (c == ')' and group[0] == '(') or \\\n           (group.count('(') != group.count(')')):\n            if is_balanced(group):\n                groups.append(group)\n            group = ''\n    if group:\n        if is_balanced(group):\n            groups.append(group)\n\n    return groups"}
{"task_id": "HumanEval/2", "completion": "    return round(number, -int(number).bit_length()) - int(number)"}
{"task_id": "HumanEval/3", "completion": "    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"task_id": "HumanEval/4", "completion": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(num - mean) for num in numbers) / len(numbers)\n\ndef absolute_value(x: float) -> float:\n    \"\"\" Returns the absolute value of a given number \"\"\"\n    return abs(x)\n\ndef standard_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Standard Deviation\n    around the mean of this dataset.\n    Standard Deviation is similar to MAD but uses squared differences instead:\n    SD = sqrt(average (x - x_mean)^2)\n    >>> standard_deviation([1.0, 2.0, 3.0, 4.0])\n    1.4142135623730951\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    variance = sum((num - mean) ** 2 for num in numbers) / len(numbers)\n    return variance ** 0.5\n\ndef median_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Median Absolute Deviation\n    around the median of this dataset.\n    Median Absolute Deviation is similar to MAD but uses median instead of mean:\n    MADM = median | x - med |\n    >>> median_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    numbers.sort()\n    mid = len(numbers) // 2\n    median = (numbers[mid] + numbers[~mid]) / 2 if len(numbers) % 2 == 0 else numbers[mid]\n    return statistics.median([abs(num - median) for num in numbers])\n\nimport statistics"}
{"task_id": "HumanEval/5", "completion": "    return [x for i, x in enumerate(numbers + [delimeter] * (len(numbers) - 1)) if i % 2 == 0]"}
{"task_id": "HumanEval/6", "completion": "    max_depth = {}\n    current_group = ''\n    max_depths = []\n\n    for char in paren_string:\n        if char == '(':\n            current_group += char\n        elif char == ')':\n            group = current_group + char\n            current_group = ''\n\n            depth = 0\n            stack = []\n            for p in group:\n                if p == '(':\n                    stack.append(p)\n                    depth += 1\n                else:\n                    stack.pop()\n                    depth -= 1\n\n            max_depth[group] = max(max_depth.get(group, 0), depth)\n\n            max_depths.append(max_depth[group])\n\n    return max_depths"}
{"task_id": "HumanEval/7", "completion": "    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/8", "completion": "    total_sum = sum(numbers) if numbers else 0\n    total_product = 1\n    for num in numbers:\n        total_product *= num\n    return total_sum, total_product"}
{"task_id": "HumanEval/9", "completion": "    result = []\n    max_so_far = float('-inf')\n    \n    for num in numbers:\n        result.append(max(num, max_so_far))\n        max_so_far = max(max_so_far, num)\n        \n    return result"}
{"task_id": "HumanEval/10", "completion": "    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    if not string:\n        return ''\n\n    i = len(string) - 1\n    while i >= 0 and string[:i+1] == string[:i+1][::-1]:\n        i -= 1\n\n    prefix = string[:i]\n    suffix = string[i:][::-1]\n\n    return prefix + suffix"}
